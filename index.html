<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="pouchdb.js"></script>
    <script src="pouchdb.indexeddb.js"></script>
    <script src="pouchdb.find.js"></script>
    <title>Document</title>
  </head>
  <body>
    <h1>PouchDB activeTasks testing</h1>

    <p>You can run the following functions in your browser's console:</p>
    <ul>
      <li>
        <code>runDummyTasks()</code>: Run some dummy tasks to test the API.
      </li>
      <li>
        <code>compactDatabase(n)</code>: Create <code>n</code> dummy documents
        in a dummy database and run a compaction task on it.
      </li>
      <li>
        <code>replicate(n1, n2, [doCleanup = true])</code>: Run a replication between two dummy
        databases. First, <code>n1</code> docs will be created on the source database and
        replicated to the destination database. Then, another <code>n2</code> docs will be
        created. The subsequent replication will make use of a checkpoint and
        replicate only the newer docs to the replication database.
        Pass in <code>false</code> as the third param to leave the DBs in place.
      </li>
      <li>
        <code>replicateLive(n1, n2, [doCleanup = true])</code>: Run a live replication between two dummy
        databases. First, `n1` docs will be created on the source database and
        a live replication to the destination database started. Then, another `n2` docs will be
        created, which should also be replicated.
        Pass in <code>false</code> as the third param to leave the DBs in place.
      </li>
      <li>
        <code>indexView(n, destroy)</code>: Create a view on a temporary
        database that has <code>n</code> documents. Then, update the index by
        running a query.
      </li>
      <li>
        <code>createFindIndex(n, q)</code>: Create a search/find index on the
        title field of a temporary database that has <code>n</code> documents.
        Then, search that index for query <code>q</code>. In order to see
        activeTasks support here, set <code>USE_INDEXEDDB_ADAPTER</code> to
        false, so the find implementation uses the underlying
        <code>p-a-m</code> module for indexing instead of IndexedDB indexes.
      </li>
    </ul>
    <p>
      You can set <code>USE_INDEXEDDB_ADAPTER</code> to true or false in order
      to choose between the indexeddb or idb adapter.
    </p>

    <script>
      let j = 0;
      let USE_INDEXEDDB_ADAPTER = true;

      PouchDB.prototype.activeTasks.add = new Proxy(
        PouchDB.prototype.activeTasks.add,
        {
          apply: (target, thisArg, argumentsList) => {
            const task = argumentsList[0];
            console.log(
              `➕ Added Task "${task.name}" with ${task.total_items} total items`
            );
            return Reflect.apply(
              target,
              PouchDB.prototype.activeTasks,
              argumentsList
            );
          },
        }
      );

      PouchDB.prototype.activeTasks.update = new Proxy(
        PouchDB.prototype.activeTasks.update,
        {
          apply: (target, thisArg, argumentsList) => {
            const task = PouchDB.prototype.activeTasks.get(argumentsList[0]);
            if (!task) return
            const durationInMilliseconds =
              new Date().getTime() - new Date(task.created_at).getTime();
            console.log(
              `🖌️ Updated Task "${task.name}" (${task.id}) with ${
                argumentsList[1].completed_items
              }/${argumentsList[1].total_items || task.total_items} items after ${
                durationInMilliseconds / 1000
              } seconds`
            );
            return Reflect.apply(
              target,
              PouchDB.prototype.activeTasks,
              argumentsList
            );
          },
        }
      );

      PouchDB.prototype.activeTasks.remove = new Proxy(
        PouchDB.prototype.activeTasks.remove,
        {
          apply: (target, thisArg, argumentsList) => {
            const task = PouchDB.prototype.activeTasks.get(argumentsList[0]);
            if (!task) return
            const err = argumentsList[1];

            const durationInMilliseconds =
              new Date(task.updated_at).getTime() -
              new Date(task.created_at).getTime();

            if (!err) {
              console.log(
                `✅ Removed/Completed Task "${task.name}" (${task.id}) with ${
                  task.completed_items
                }/${task.total_items} items after ${
                  durationInMilliseconds / 1000
                } seconds`
              );
            } else {
              console.log(
                `❌ Failed Task "${task.name}" (${task.id}) with ${
                  task.completed_items
                }/${task.total_items} items after ${
                  durationInMilliseconds / 1000
                } seconds. Reason: ${err}`
              );
            }
            return Reflect.apply(
              target,
              PouchDB.prototype.activeTasks,
              argumentsList
            );
          },
        }
      );

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      async function runDummyTasks() {
        const id1 = PouchDB.activeTasks.add({
          name: "Task 1",
          total_items: 12,
        });
        const id2 = PouchDB.activeTasks.add({
          name: "Task 2",
          total_items: 432,
        });
        const id3 = PouchDB.activeTasks.add({
          name: "Task 3",
          total_items: 12098,
        });
        await sleep(500);
        PouchDB.activeTasks.update(id1, { completed_items: 1 });
        PouchDB.activeTasks.update(id3, { completed_items: 1441 });
        await sleep(1800);
        PouchDB.activeTasks.update(id1, { completed_items: 2 });
        PouchDB.activeTasks.update(id2, { completed_items: 144 });
        await sleep(2200);
        PouchDB.activeTasks.update(id3, { completed_items: 8441 });
        PouchDB.activeTasks.update(id2, { completed_items: 223 });
        await sleep(1900);
        PouchDB.activeTasks.update(id1, { completed_items: 10 });
        await sleep(500);
        PouchDB.activeTasks.update(id1, { completed_items: 12 });
        PouchDB.activeTasks.remove(id1);
        PouchDB.activeTasks.update(id2, { completed_items: 423 });
        await sleep(1100);
        PouchDB.activeTasks.update(id3, { completed_items: 12001 });
        await sleep(1050);
        PouchDB.activeTasks.update(id2, { completed_items: 432 });
        PouchDB.activeTasks.remove(id2);
        await sleep(2100);
        PouchDB.activeTasks.update(id3, { completed_items: 12098 });
        PouchDB.activeTasks.remove(id3);
      }

      async function createDummyDocs(db, n = 100) {
        for (let i = 0; i < n; i++, j++) {
          await db.put({
            _id: `dummy-${j}`,
            index: j,
            title: `Dummy item ${j}`,
          });
        }
      }

      function createPouchDB(name) {
        const adapter = USE_INDEXEDDB_ADAPTER ? "indexeddb" : "idb";
        return new PouchDB(name, { adapter });
      }

      async function replicate(n1 = 1000, n2 = 100, doCleanup = true) {
        const src = createPouchDB("replication-test-src");
        const dst = createPouchDB("replication-test-dst");

        console.log(`~~~ creating ${n1} dummy docs`);
        await createDummyDocs(src, n1);

        console.log("~~~ replicating (1)");
        await src.replicate.to(dst);

        console.log(`~~~ creating ${n2} dummy docs`);
        await createDummyDocs(src, n2);

        console.log("~~~ replicating (2)");
        await src.replicate.to(dst);

        if (doCleanup) {
          await src.destroy();
          await dst.destroy();
          console.log('~~~ 🧹 cleaned up replication DBs')
        }
      }

      async function replicateLive(n1 = 1000, n2 = 100, doCleanup = true) {
        const src = createPouchDB("live-replication-test-src");
        const dst = createPouchDB("live-replication-test-dst");

        console.log(`~~~ creating ${n1} dummy docs`);
        await createDummyDocs(src, n1);

        console.log("~~~ starting continuous replication (1)");
        const liveReplication = PouchDB.replicate(src, dst, {live: true})
        // .on('change', function (info) {
        //   console.log('~~~ live replication change', info)
        // }).on('paused', function (err) {
        //   console.log('~~~ live replication paused', err)
        // }).on('active', function () {
        //   console.log('~~~ live replication active')
        // }).on('denied', function (err) {
        //   console.log('~~~ live replication denied', err)
        // }).on('complete', function (info) {
        //   console.log('~~~ live replication complete', info)
        // }).on('error', function (err) {
        //   console.log('~~~ live replication error', err)
        // });

        console.log("~~~ waiting a bit");
        await sleep(3000);

        console.info(`~~~ creating ${n2} dummy docs`);
        await createDummyDocs(src, n2);
        console.info(`~~~ created ${n2} dummy docs, sync should restart`);

        console.log("~~~ waiting a bit longer");
        await sleep(3000);

        liveReplication.cancel()

        if (doCleanup) {
          await src.destroy();
          await dst.destroy();
          console.log('~~~ 🧹 cleaned up live replication DBs')
        }
      }

      async function compactDatabase(n = 1000) {
        const db = createPouchDB("database-compaction-test");
        await createDummyDocs(db, n);
        db._compact({}, () => {
          db.destroy();
        });
      }

      async function indexView(n = 1000, destroy = true) {
        const db = createPouchDB("view-indexing-test");
        await createDummyDocs(db, n);
        await db.put({
          _id: "_design/my_index",
          views: {
            by_index: {
              map: function (doc) {
                emit(doc.index);
              }.toString(),
            },
          },
        });

        // the _design doc will create one further doc in the database, so we
        // will iterate over n+1 changes here (which is okay by design), but
        // the query will return n docs and ignore the _design doc.
        console.log(await db.query("my_index/by_index"));

        if (destroy) {
          await db.destroy();
        }
      }

      async function createFindIndex(
        n = 1000,
        q = "Dummy item 499",
        opts = {}
      ) {
        const destroy = opts.destroy === false ? false : true;

        const db = createPouchDB("create-find-index-test");
        await createDummyDocs(db, n);
        await db.createIndex({
          index: { fields: ["title"] },
        });

        console.log(
          await db.find({
            selector: {
              title: { $eq: q },
            },
          })
        );

        if (destroy) {
          await db.destroy();
        }
      }
    </script>
  </body>
</html>
